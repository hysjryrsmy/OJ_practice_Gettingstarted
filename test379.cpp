
#define _CRT_SECURE_NO_WARING

#include <iostream>
#include <stack>
#include <cstdio>
using namespace std;

//​ 某仓库购入新的货物（每次购入的货物均不同）并将一部分老货物发出，这个过程会有软件对数据以日志形式保存，规则如下：
//​ 该日志记录了两类操作：第一类操作为入库操作，以及该次入库的货物数量；第二类操作为出库操作。
//这些记录都严格按时间顺序排列。入库和出库的规则为先进后出，即每次出库操作货物为当前在仓库里所有货物中最晚入库的货物。
//​ 为了便于分析，现在加入了第三类查询操作，每次查询时，输出当前仓库数量最多的货物的数量。

//输入
//​ 包含 N + 1 行：
//​ 第一行为 1 个正整数 N，对应于日志内所含操作的总数。
//​ 接下来的 N 行，分别属于以下三种格式之一：
//​ 格式 1: 0 X //一次入库操作，正整数 X 表示该次入库的货物的数量
//​ 格式 2 : 1 //一次出库操作，（就当时而言）最后入库的货物出库
//​ 格式 3 : 2 //一次查询操作，要求分析程序输出当前仓库内数量最多的货物的数量
//​ 当仓库为空时你应该忽略出库操作，当仓库为空查询时你应该输出 0。
//​ 初始时仓库状态为空。

//输出
//​ 输出行数等于日志中查询操作的次数。每行为一个正整数，表示查询结果。


int main() {
	int n;
	stack<int> sta, mmax;
	mmax.push(0);
	scanf("%d", &n);
	for (int i = 0; i < n; i++) {
		int t;
		scanf("%d", &t);
		if (t == 0) {
			scanf("%d", &t);
			sta.push(t);
			mmax.push(max(mmax.top(), t));
		}
		else if (t == 1) {
			if (!sta.empty()) {
				sta.pop();
				mmax.pop();
			}
		}
		else {
			printf("%d\n", mmax.top()); 
		}
	}

	return 0;
}